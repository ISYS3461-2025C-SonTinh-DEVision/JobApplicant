# spring:
#   application:
#     name: springauth
#   datasource:
#     url: jdbc:h2:mem:mydb
#     username: sa
#     password: password
#     driverClassName: org.h2.Driver
#   jpa:
#     database-platform: org.hibernate.dialect.H2Dialect

#   h2:
#     console:
#       enabled: true

server:
  port: ${SERVER_PORT:8080}

app:
  frontend:
    base-url: ${FRONTEND_BASE_URL:http://localhost:3000}
  job-manager:
    base-url: ${JOB_MANAGER_BASE_URL:http://localhost:8081}
  mail:
    from: ${MAIL_FROM:onboarding@resend.dev}  
    from-name: ${MAIL_FROM_NAME:DEVision}
    resend:
      # Resend API Key for HTTP-based email sending (avoids SMTP port blocking)
      api-key: ${MAIL_PASSWORD:re_LiDzSkL7_HtCBpf7dvcrRbi3kSDLyMH8P}

cloudinary:
  cloud-name: ${CLOUDINARY_CLOUD_NAME}
  api-key: ${CLOUDINARY_API_KEY}
  api-secret: ${CLOUDINARY_API_SECRET}

spring:
  servlet:
    multipart:
      enabled: true
      max-file-size: 100MB
      max-request-size: 200MB
      file-size-threshold: 2KB
  
  data:
    mongodb:
      uri: ${MONGODB_URI}
      database: JA-DB

    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      database: 0
      timeout: 60000
      jedis:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0
          max-wait: -1

  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
      properties:
        spring.json.add.type.headers: false
    consumer:
      group-id: job-applicant-search-profile-group
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"


jm:
  service:
    url: ${JOB_MANAGER_SERVICE_URL:http://localhost:3000}
    email: ${JOB_MANAGER_SERVICE_EMAIL:}
    password: ${JOB_MANAGER_SERVICE_PASSWORD:}

  # SMTP configuration removed - using Resend HTTP API instead
  # This avoids SMTP port blocking issues on Railway and other cloud platforms
  # mail:
  #   host: smtp.resend.com
  #   port: 587
  #   username: ${MAIL_USERNAME}
  #   password: ${MAIL_PASSWORD}

  # Google OAuth2 SSO Configuration (Requirement 1.3.1 - Ultimo)
  # Note: Our implementation uses ID Token Flow via OAuth2Service
  # This config provides the client-id for token verification
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: ${GOOGLE_CLIENT_ID}
            client-secret: ${GOOGLE_CLIENT_SECRET}
            scope:
              - email
              - profile
            redirect-uri: "{baseUrl}/api/auth/oauth2/callback/{registrationId}"
            authorization-grant-type: authorization_code
        provider:
          google:
            authorization-uri: https://accounts.google.com/o/oauth2/v2/auth
            token-uri: https://oauth2.googleapis.com/token
            user-info-uri: https://www.googleapis.com/oauth2/v3/userinfo
            user-name-attribute: sub

# firebase:
#     bucket-name: ${FIREBASE_BUCKET_NAME}
#     project-id: ${FIREBASE_PROJECT_ID}
#     credentials-path: ${FIREBASE_CREDENTIALS_PATH}

# jwt:
#     secret: ${JWT_SECRET}
#     expiration: ${JWT_EXPIRATION}
#     refresh-expiration: ${JWT_REFRESH_EXPIRATION}



# System-to-System Authentication Configuration
# Configure these for Job Manager System authorization
